(self.webpackChunkrlayers=self.webpackChunkrlayers||[]).push([[6502],{26502:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>n});const n="import React, {useCallback} from 'react';\r\nimport {fromLonLat} from 'ol/proj';\r\nimport GeoJSON from 'ol/format/GeoJSON';\r\nimport {createEmpty, extend, getHeight, getWidth} from 'ol/extent';\r\nimport 'ol/ol.css';\r\n\r\n// This example illustrates the versatility of a dynamic RStyle\r\n// It also makes use of its caching abilities\r\nimport {RMap, RLayerStamen, RLayerCluster} from 'rlayers';\r\nimport {RStyle, RFill, RStroke, RRegularShape, RCircle, RText} from 'rlayers/style';\r\n\r\n// Earthquakes of magnitude of at least 3.0 in 2020 (courtesy of USGS)\r\nimport earthquakes from '!!file-loader!./data/earthquakes.geojson';\r\ntype InputFormEventType = React.FormEvent<HTMLInputElement>;\r\nconst reader = new GeoJSON({featureProjection: 'EPSG:3857'});\r\n\r\nconst colorBlob = (size) =>\r\n    'rgba(' + [255, 153, 0, Math.min(0.8, 0.4 + Math.log(size / 10) / 20)].join() + ')';\r\nconst radiusStar = (feature) => Math.round(5 * (parseFloat(feature.get('mag')) - 2.5));\r\n\r\n// This returns the north/south east/west extent of a group of features\r\n// divided by the resolution\r\nconst extentFeatures = (features, resolution) => {\r\n    const extent = createEmpty();\r\n    for (const f of features) extend(extent, f.getGeometry().getExtent());\r\n    return Math.round(0.25 * (getWidth(extent) + getHeight(extent))) / resolution;\r\n};\r\n\r\nexport default function Cluster(): JSX.Element {\r\n    const [distance, setDistance] = React.useState(20);\r\n    const earthquakeLayer = React.useRef();\r\n    return (\r\n        <React.Fragment>\r\n            <RMap className='example-map' center={fromLonLat([0, 0])} zoom={1}>\r\n                <RLayerStamen layer='toner' />\r\n                <RLayerCluster\r\n                    ref={earthquakeLayer}\r\n                    distance={distance}\r\n                    format={reader}\r\n                    url={earthquakes}\r\n                >\r\n                    <RStyle\r\n                        cacheSize={1024}\r\n                        cacheId={useCallback(\r\n                            (feature, resolution) =>\r\n                                // This is the hashing function, it takes a feature as its input\r\n                                // and returns a string\r\n                                // It must be dependant of the same inputs as the rendering function\r\n                                feature.get('features').length > 1\r\n                                    ? '#' + extentFeatures(feature.get('features'), resolution)\r\n                                    : '$' + radiusStar(feature.get('features')[0]),\r\n                            []\r\n                        )}\r\n                        render={useCallback((feature, resolution) => {\r\n                            // This is the rendering function\r\n                            // It has access to the cluster which appears as a single feature\r\n                            // and has a property with an array of all the features that make it\r\n                            const size = feature.get('features').length;\r\n                            // This is the size (number of features) of the cluster\r\n                            if (size > 1) {\r\n                                // Render a blob with a number\r\n                                const radius = extentFeatures(feature.get('features'), resolution);\r\n                                return (\r\n                                    <React.Fragment>\r\n                                        <RCircle radius={radius}>\r\n                                            <RFill color={colorBlob(size)} />\r\n                                        </RCircle>\r\n                                        <RText text={size.toString()}>\r\n                                            <RFill color='#fff' />\r\n                                            <RStroke color='rgba(0, 0, 0, 0.6)' width={3} />\r\n                                        </RText>\r\n                                    </React.Fragment>\r\n                                );\r\n                            }\r\n                            // We have a single feature cluster\r\n                            const unclusteredFeature = feature.get('features')[0];\r\n                            // Render a star\r\n                            return (\r\n                                <RRegularShape\r\n                                    radius1={radiusStar(unclusteredFeature)}\r\n                                    radius2={3}\r\n                                    points={5}\r\n                                    angle={Math.PI}\r\n                                >\r\n                                    <RFill color='rgba(255, 153, 0, 0.8)' />\r\n                                    <RStroke color='rgba(255, 204, 0, 0.2)' width={1} />\r\n                                </RRegularShape>\r\n                            );\r\n                        }, [])}\r\n                    />\r\n                </RLayerCluster>\r\n            </RMap>\r\n            <div className='my-3 w-100'>\r\n                <label htmlFor='distance'>Clustering distance</label>\r\n                <div className='w-100'>\r\n                    <input\r\n                        type='range'\r\n                        className='range-slider range-slider--primary w-100'\r\n                        min='5'\r\n                        max='50'\r\n                        id='distance'\r\n                        value={distance}\r\n                        onChange={useCallback(\r\n                            (e: InputFormEventType) => setDistance(parseInt(e.currentTarget.value)),\r\n                            []\r\n                        )}\r\n                    />\r\n                </div>\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n"}}]);