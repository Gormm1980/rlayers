(self.webpackChunkrlayers=self.webpackChunkrlayers||[]).push([[8919],{78919:(r,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>o});const o="import React, {useCallback} from 'react';\r\nimport {fromLonLat, toLonLat} from 'ol/proj';\r\nimport {Coordinate} from 'ol/coordinate';\r\nimport {Point} from 'ol/geom';\r\nimport 'ol/ol.css';\r\n\r\nimport {RMap, ROSM, RLayerVector, RFeature, ROverlay, RStyle} from 'rlayers';\r\nimport locationIcon from './svg/location.svg';\r\n\r\nconst coords: Record<string, Coordinate> = {\r\n    origin: [2.364, 48.82],\r\n    Montmartre: [2.342, 48.887]\r\n};\r\n\r\n// This example is meant to illustrate the use of the various RFeature callbacks\r\n// If you simply want to implement a translation interaction, the Interactions\r\n// example has a method which handles the pointer movements internally\r\n// with a much better performance\r\nexport default function PinDrop(): JSX.Element {\r\n    const [loc, setLoc] = React.useState(coords.Montmartre);\r\n    return (\r\n        <React.Fragment>\r\n            <RMap className='example-map' center={fromLonLat(coords.origin)} zoom={11}>\r\n                <ROSM />\r\n                <RLayerVector>\r\n                    <RFeature\r\n                        geometry={new Point(fromLonLat(loc))}\r\n                        // useCallback is here for performance reasons\r\n                        // without it RFeature will have its props updated at every call\r\n                        onPointerDrag={useCallback((e) => {\r\n                            const coords = e.map.getCoordinateFromPixel(e.pixel);\r\n                            e.target.setGeometry(new Point(coords));\r\n                            // this stops OpenLayers from interpreting the event to pan the map\r\n                            e.preventDefault();\r\n                        }, [])}\r\n                        onPointerDragEnd={useCallback((e) => {\r\n                            const coords = e.map.getCoordinateFromPixel(e.pixel);\r\n                            setLoc(toLonLat(coords));\r\n                        }, [])}\r\n                        onPointerEnter={useCallback(\r\n                            (e) => (e.map.getTargetElement().style.cursor = 'move') && undefined,\r\n                            []\r\n                        )}\r\n                        onPointerLeave={useCallback(\r\n                            (e) => (e.map.getTargetElement().style.cursor = 'initial') && undefined,\r\n                            []\r\n                        )}\r\n                    >\r\n                        <RStyle.RStyle>\r\n                            <RStyle.RIcon src={locationIcon} anchor={[0.5, 0.8]} />\r\n                        </RStyle.RStyle>\r\n                        <ROverlay className='example-overlay'>Move me</ROverlay>\r\n                    </RFeature>\r\n                </RLayerVector>\r\n            </RMap>\r\n            <div className='mx-0 mt-0 mb-3 p-1 w-100 jumbotron shadow shadow'>\r\n                <p>\r\n                    Pin location is <strong>{`${loc[1].toFixed(3)} : ${loc[0].toFixed(3)}`}</strong>\r\n                </p>\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n"}}]);