(self.webpackChunkrlayers=self.webpackChunkrlayers||[]).push([[6400],{6400:(e,r,n)=>{"use strict";n.r(r),n.d(r,{default:()=>t});const t="/* This example reimplements the excellent OpenLayers example by @twpayne\r\n * from https://openlayers.org/en/latest/examples/igc.html\r\n * It illustrates various techniques that can be used to greatly improve performance\r\n *\r\n * React makes creating complex web applications very easy\r\n * It also makes very easy writing terribly inefficient code\r\n * You can get away with it when your DOM is not too complex\r\n * But when dealing with a canvas-drawn map, every care must be\r\n * taken to avoid unnecessary re-rendering\r\n */\r\n\r\nimport React, {useCallback} from 'react';\r\nimport {fromLonLat} from 'ol/proj';\r\nimport IGC from 'ol/format/IGC';\r\nimport {getVectorContext} from 'ol/render';\r\nimport {LineString, Point} from 'ol/geom';\r\n\r\nimport {\r\n    RMap,\r\n    RLayerTile,\r\n    RLayerVector,\r\n    RFeature,\r\n    RenderEvent,\r\n    MapBrowserEvent,\r\n    VectorSourceEvent\r\n} from 'rlayers';\r\nimport {RStyle, RStroke, RFill, RCircle, useRStyle} from 'rlayers/style';\r\nimport 'ol/ol.css';\r\n\r\nimport ClementLatour from '!!file-loader!./data/igc/Clement-Latour.igc';\r\nimport DamienDeBaenst from '!!file-loader!./data/igc/Damien-de-Baenst.igc';\r\nimport SylvainDhonneur from '!!file-loader!./data/igc/Sylvain-Dhonneur.igc';\r\nimport TomPayne from '!!file-loader!./data/igc/Tom-Payne.igc';\r\nimport UlrichPrinz from '!!file-loader!./data/igc/Ulrich-Prinz.igc';\r\n\r\ntype InputFormEventType = React.FormEvent<HTMLInputElement>;\r\n\r\nconst igcsDesc = [\r\n    {c: 'rgba(0, 0, 250, 0.7)', i: ClementLatour},\r\n    {c: 'rgba(0, 50, 200, 0.7)', i: DamienDeBaenst},\r\n    {c: 'rgba(0, 100, 150, 0.7)', i: SylvainDhonneur},\r\n    {c: 'rgba(0, 150, 200, 0.7)', i: TomPayne},\r\n    {c: 'rgba(0, 200, 50, 0.7)', i: UlrichPrinz}\r\n];\r\n\r\n// A constant avoids re-rendering of the component\r\n// a property initialized with an anonymous object is not constant\r\n// it will recreate a new instance at every evaluation\r\nconst origin = fromLonLat([6, 45.7]);\r\n\r\n// This part is re-rendered on every pointermove\r\nexport default function IGCComp(): JSX.Element {\r\n    const [time, setTime] = React.useState('');\r\n    const [point, setPoint] = React.useState(null as Point);\r\n    const [line, setLine] = React.useState(null as LineString);\r\n    const [slider, setSlider] = React.useState(0);\r\n    const [highlights, setHighlights] = React.useState([]);\r\n    const [flight, setFlight] = React.useState({\r\n        start: Infinity,\r\n        stop: -Infinity,\r\n        duration: 0\r\n    });\r\n    const [igcs, setIgcs] = React.useState(() => {\r\n        Promise.all(igcsDesc.map((i) => fetch(i.i).then((r) => r.text()))).then((r) => setIgcs(r));\r\n        return [];\r\n    });\r\n\r\n    const styles = {\r\n        redCircle: useRStyle(),\r\n        blueCircle: useRStyle(),\r\n        // This is a technique for an array of React.RefObjects\r\n        // It is ugly but it works\r\n        flightPath: React.useRef([]) as React.RefObject<RStyle[]>\r\n    };\r\n\r\n    // createRef insted of useRef here will severely impact performance\r\n    const igcVectorLayer = React.useRef() as React.RefObject<RLayerVector>;\r\n    const highlightVectorLayer = React.useRef() as React.RefObject<RLayerVector>;\r\n\r\n    return (\r\n        <React.Fragment>\r\n            {React.useMemo(\r\n                // This is not a dynamic RStyle, these are 5 static RStyle's\r\n                // Thus the useMemo\r\n                () =>\r\n                    igcsDesc.map((igc, idx) => (\r\n                        <RStyle key={idx} ref={(el) => (styles.flightPath.current[idx] = el)}>\r\n                            <RStroke color={igc.c} width={3} />\r\n                        </RStyle>\r\n                    )),\r\n                [styles.flightPath]\r\n            )}\r\n            <RStyle ref={styles.redCircle}>\r\n                <RStroke color='red' width={1} />\r\n                <RCircle radius={6}>\r\n                    <RFill color='red' />\r\n                </RCircle>\r\n            </RStyle>\r\n            <RStyle ref={styles.blueCircle}>\r\n                <RCircle radius={6}>\r\n                    <RFill color='blue' />\r\n                </RCircle>\r\n            </RStyle>\r\n            <RMap\r\n                className='example-map'\r\n                center={origin}\r\n                zoom={9}\r\n                onPointerMove={useCallback(\r\n                    (e: MapBrowserEvent) => {\r\n                        // This useCallback is very important -> without it\r\n                        // onPointerMove will be a new anonymous function on every render\r\n                        const source = igcVectorLayer.current.source;\r\n                        const feature = source.getClosestFeatureToCoordinate(e.coordinate);\r\n                        const point = feature.getGeometry().getClosestPoint(e.coordinate);\r\n                        const date = new Date(point[2] * 1000);\r\n                        setPoint(new Point(point));\r\n                        setLine(new LineString([e.coordinate, [point[0], point[1]]]));\r\n                        setTime(\r\n                            '<strong>' +\r\n                                feature.get('PLT') +\r\n                                '</strong><br><em>' +\r\n                                date.toUTCString() +\r\n                                '</em>'\r\n                        );\r\n                        e.map.render();\r\n                    },\r\n                    [igcVectorLayer]\r\n                )}\r\n            >\r\n                <RLayerTile\r\n                    zIndex={5}\r\n                    url='https://{a-c}.tile.opentopomap.org/{z}/{x}/{y}.png'\r\n                    attributions='Kartendaten: © OpenStreetMap-Mitwirkende, SRTM | Kartendarstellung: © OpenTopoMap (CC-BY-SA)'\r\n                />\r\n                <RLayerVector\r\n                    zIndex={10}\r\n                    ref={igcVectorLayer}\r\n                    onAddFeature={useCallback(\r\n                        // This useCallback transforms this function to a constant value\r\n                        // None of its dependencies change after initialization\r\n                        (e: VectorSourceEvent) => {\r\n                            const geometry = e.feature.getGeometry() as LineString;\r\n                            flight.start = Math.min(flight.start, geometry.getFirstCoordinate()[2]);\r\n                            flight.stop = Math.max(flight.stop, geometry.getLastCoordinate()[2]);\r\n                            flight.duration = flight.stop - flight.start;\r\n                            setFlight({...flight});\r\n                        },\r\n                        [flight]\r\n                    )}\r\n                    onPostRender={useCallback(\r\n                        // This useCallback is less efficient than the previous one\r\n                        // as it depends on the state\r\n                        // LayerVector is re-rendered every time point/line change\r\n                        (e: RenderEvent) => {\r\n                            const vectorContext = getVectorContext(e);\r\n                            vectorContext.setStyle(RStyle.getStyleStatic(styles.redCircle));\r\n                            if (point && line) {\r\n                                vectorContext.drawGeometry(point);\r\n                                vectorContext.drawGeometry(line);\r\n                            }\r\n                        },\r\n                        [point, line, styles.redCircle]\r\n                    )}\r\n                >\r\n                    {React.useMemo(\r\n                        () => (\r\n                            // This component appears dynamic to React because of the map but it is in fact constant\r\n                            // useMemo will render it truly constant\r\n                            <React.Fragment>\r\n                                {igcs.map((igc, idx) => (\r\n                                    <RFeature\r\n                                        key={idx}\r\n                                        feature={\r\n                                            new IGC().readFeatures(igc, {\r\n                                                featureProjection: 'EPSG:3857'\r\n                                            })[0]\r\n                                        }\r\n                                        style={styles.flightPath.current[idx]}\r\n                                    />\r\n                                ))}\r\n                            </React.Fragment>\r\n                        ),\r\n                        // The array trick renders it impossible for React to track the useMemo dependencies\r\n                        // -> we do it manually\r\n                        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n                        [igcs, styles.flightPath, styles.flightPath.current[0]]\r\n                    )}\r\n                </RLayerVector>\r\n                <RLayerVector zIndex={10} ref={highlightVectorLayer} style={styles.blueCircle}>\r\n                    {React.useMemo(\r\n                        () => (\r\n                            // This component appears dynamic to React because of the map but it is in fact constant\r\n                            // useMemo will render it truly constant\r\n                            <React.Fragment>\r\n                                {highlights.map((coords, i) => (\r\n                                    <RFeature key={i} geometry={new Point(coords)} />\r\n                                ))}\r\n                            </React.Fragment>\r\n                        ),\r\n                        [highlights]\r\n                    )}\r\n                </RLayerVector>\r\n            </RMap>\r\n            <div className='d-flex flex-row mb-3 align-items-center'>\r\n                <div\r\n                    className='jumbotron py-1 px-3 m-0 mr-3 w-50'\r\n                    dangerouslySetInnerHTML={{__html: time}}\r\n                />\r\n                <div className='w-50'>\r\n                    <input\r\n                        type='range'\r\n                        className='range-slider range-slider--primary w-100'\r\n                        min='0'\r\n                        max='100'\r\n                        value={slider}\r\n                        onChange={useCallback(\r\n                            // This useCallback transforms this function to a constant value\r\n                            // None of its dependencies change after initialization\r\n                            // A normal function instead of an arrow lambda allows to access\r\n                            // the context in this\r\n                            function (e: InputFormEventType) {\r\n                                const value = parseInt(e.currentTarget.value);\r\n                                setSlider(value);\r\n                                const source = igcVectorLayer.current.source;\r\n                                const m = flight.start + (flight.duration * value) / 100;\r\n                                const newHighlights = [];\r\n                                source.forEachFeature((feature) => {\r\n                                    if (!feature.get('PLT')) return;\r\n                                    const geometry = feature.getGeometry() as LineString;\r\n                                    const coords = geometry.getCoordinateAtM(m, true);\r\n                                    newHighlights.push(coords);\r\n                                });\r\n                                setHighlights(newHighlights);\r\n                                this.context.map.render();\r\n                            },\r\n                            [igcVectorLayer, flight]\r\n                        )}\r\n                    />\r\n                </div>\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n"}}]);